<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç¶“å…¸æ³¡æ³¡é¾ (Bubble Bobble Style)</title>
    <style>
        body {
            margin: 0;
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        canvas {
            background-color: #000;
            display: block;
            border: 4px solid #444;
            border-radius: 4px;
        }
        #ui-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }
        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }
        .hidden {
            display: none !important;
        }
        h1 {
            font-size: 48px;
            margin-bottom: 10px;
            color: #50e3c2;
            text-shadow: 4px 4px 0 #2c7a68;
        }
        p {
            font-size: 18px;
            line-height: 1.6;
            color: #ccc;
        }
        .btn {
            margin-top: 30px;
            padding: 12px 30px;
            font-size: 24px;
            background: #e91e63;
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            box-shadow: 0 4px 0 #ad1457;
        }
        .btn:hover {
            background: #f06292;
            transform: translateY(-2px);
        }
        .btn:active {
            transform: translateY(2px);
            box-shadow: none;
        }
        .controls-hint {
            margin-top: 20px;
            font-size: 14px;
            color: #888;
        }
        .key {
            background: #444;
            padding: 2px 8px;
            border-radius: 4px;
            color: white;
            font-family: monospace;
            border-bottom: 2px solid #222;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="ui-overlay">
        <div>SCORE: <span id="score">0</span></div>
        <div>LIVES: <span id="lives">3</span></div>
    </div>

    <div id="start-screen">
        <h1>BUBBLE HERO</h1>
        <p>è‡´æ•¬ 1986 å¹´ç¶“å…¸è¡—æ©ŸéŠæˆ²</p>
        <p>åæ³¡æ³¡å›°ä½æ•µäººï¼Œç„¶å¾Œæ’ç ´æ³¡æ³¡å¾—åˆ†ï¼</p>
        <button class="btn" onclick="startGame()">START GAME</button>
        <div class="controls-hint">
            ç§»å‹•: <span class="key">â†</span> <span class="key">â†’</span> | 
            è·³èº: <span class="key">â†‘</span> | 
            åæ³¡æ³¡: <span class="key">ç©ºç™½éµ</span>
        </div>
    </div>

    <div id="game-over-screen" class="hidden">
        <h1>GAME OVER</h1>
        <p>æœ€çµ‚åˆ†æ•¸: <span id="final-score">0</span></p>
        <button class="btn" onclick="resetGame()">TRY AGAIN</button>
    </div>
</div>

<script>
/**
 * éŠæˆ²å¸¸æ•¸èˆ‡è¨­å®š
 */
const CANVAS_WIDTH = 800;
const CANVAS_HEIGHT = 600;
const GRAVITY = 0.5;
const FRICTION = 0.8;
const PLAYER_SPEED = 5;
const JUMP_FORCE = -12;
const BUBBLE_SPEED = 6;
const BUBBLE_FLOAT_SPEED = -0.5; // æ³¡æ³¡å‘ä¸Šé£„çš„é€Ÿåº¦
const BUBBLE_LIFETIME = 300; // æ³¡æ³¡å­˜æ´»æ™‚é–“ (frames)

// éŠæˆ²ç‹€æ…‹
let canvas, ctx;
let lastTime = 0;
let score = 0;
let lives = 3;
let gameOver = false;
let animationId;
let frameCount = 0;

// è¼¸å…¥ç‹€æ…‹
const keys = {
    ArrowLeft: false,
    ArrowRight: false,
    ArrowUp: false,
    Space: false
};

// å¯¦é«”åˆ—è¡¨
let player;
let platforms = [];
let bubbles = [];
let enemies = [];
let fruits = [];
let particles = [];

/**
 * åŸºç¤å¯¦é«”é¡åˆ¥
 */
class Entity {
    constructor(x, y, width, height, color) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.vx = 0;
        this.vy = 0;
        this.color = color;
        this.markedForDeletion = false;
        this.grounded = false;
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
    }

    // ç°¡å–®çš„ AABB ç¢°æ’æª¢æ¸¬
    collidesWith(other) {
        return (
            this.x < other.x + other.width &&
            this.x + this.width > other.x &&
            this.y < other.y + other.height &&
            this.y + this.height > other.y
        );
    }
}

/**
 * ç©å®¶é¡åˆ¥
 */
class Player extends Entity {
    constructor(x, y) {
        super(x, y, 30, 30, '#50e3c2'); // é’ç¶ è‰²å°é¾
        this.facingRight = true;
        this.shootCooldown = 0;
        this.isInvincible = false;
        this.invincibleTimer = 0;
    }

    update() {
        // æ°´å¹³ç§»å‹•
        if (keys.ArrowRight) {
            this.vx = PLAYER_SPEED;
            this.facingRight = true;
        } else if (keys.ArrowLeft) {
            this.vx = -PLAYER_SPEED;
            this.facingRight = false;
        } else {
            this.vx *= FRICTION;
        }

        // è·³èº
        if (keys.ArrowUp && this.grounded) {
            this.vy = JUMP_FORCE;
            this.grounded = false;
        }

        // å°„æ“Š
        if (keys.Space && this.shootCooldown <= 0) {
            shootBubble(this);
            this.shootCooldown = 20; // å†·å»æ™‚é–“
        }
        if (this.shootCooldown > 0) this.shootCooldown--;

        // é‡åŠ›
        this.vy += GRAVITY;

        // æ›´æ–°ä½ç½®
        super.update();

        // å¹³å°ç¢°æ’èˆ‡é‚Šç•Œè™•ç†
        this.grounded = false;
        
        // ç°¡æ˜“è¢å¹•é‚Šç•Œé™åˆ¶ (å·¦å³å¯ç©¿è¶Šæ˜¯ç¶“å…¸è¨­å®šï¼Œé€™è£¡å…ˆåšæˆç‰†å£é˜²æ­¢è¿·è·¯)
        if (this.x < 0) this.x = 0;
        if (this.x + this.width > CANVAS_WIDTH) this.x = CANVAS_WIDTH - this.width;

        // åœ°æ¿/å¹³å°ç¢°æ’
        for (let platform of platforms) {
            if (this.vy >= 0 && // åªæœ‰å¾€ä¸‹æ‰çš„æ™‚å€™æ‰æœƒè¸©åˆ°å¹³å°
                this.x < platform.x + platform.width &&
                this.x + this.width > platform.x &&
                this.y + this.height > platform.y &&
                this.y + this.height < platform.y + platform.height + 10) { // +10 æ˜¯å®¹éŒ¯
                
                this.y = platform.y - this.height;
                this.vy = 0;
                this.grounded = true;
            }
        }

        // æ‰å‡ºç•«é¢åº•éƒ¨å›åˆ°é ‚éƒ¨ (ç¶“å…¸æ©Ÿåˆ¶)
        if (this.y > CANVAS_HEIGHT) {
            this.y = 0;
        }

        // ç„¡æ•µæ™‚é–“é–ƒçˆè™•ç†
        if (this.isInvincible) {
            this.invincibleTimer--;
            if (this.invincibleTimer <= 0) {
                this.isInvincible = false;
            }
        }
    }

    draw(ctx) {
        if (this.isInvincible && Math.floor(Date.now() / 100) % 2 === 0) return; // é–ƒçˆ

        // ç°¡å–®ç¹ªè£½æé¾å½¢ç‹€
        ctx.save();
        ctx.translate(this.x + this.width/2, this.y + this.height/2);
        if (!this.facingRight) ctx.scale(-1, 1);
        
        // èº«é«”
        ctx.fillStyle = '#50e3c2';
        ctx.beginPath();
        ctx.arc(0, 0, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // å°¾å·´
        ctx.beginPath();
        ctx.moveTo(-10, 5);
        ctx.lineTo(-20, 0);
        ctx.lineTo(-10, -5);
        ctx.fill();

        // çœ¼ç›
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(5, -5, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(7, -5, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // èƒŒé°­
        ctx.fillStyle = '#ffeb3b';
        ctx.beginPath();
        ctx.moveTo(-12, -5);
        ctx.lineTo(-18, -12);
        ctx.lineTo(-5, -10);
        ctx.fill();

        ctx.restore();
    }

    hit() {
        if (this.isInvincible) return;
        
        lives--;
        document.getElementById('lives').textContent = lives;
        
        // ç”¢ç”Ÿç²’å­æ•ˆæœ
        createParticles(this.x + this.width/2, this.y + this.height/2, '#50e3c2', 20);

        if (lives <= 0) {
            gameOver = true;
            document.getElementById('final-score').textContent = score;
            document.getElementById('game-over-screen').classList.remove('hidden');
        } else {
            // é‡ç”Ÿ
            this.x = 50;
            this.y = CANVAS_HEIGHT - 100;
            this.vx = 0;
            this.vy = 0;
            this.isInvincible = true;
            this.invincibleTimer = 120; // 2ç§’ç„¡æ•µ
        }
    }
}

/**
 * æ•µäººé¡åˆ¥
 */
class Enemy extends Entity {
    constructor(x, y) {
        super(x, y, 30, 30, '#ff5252');
        this.vx = 2; // åˆå§‹é€Ÿåº¦
        this.directionTimer = 0;
        this.state = 'active'; // 'active', 'trapped'
        this.trappedTimer = 0;
    }

    update() {
        if (this.state === 'active') {
            // ç°¡å–® AI: æ’ç‰†åå½ˆï¼Œéš¨æ©Ÿè·³èº
            this.vy += GRAVITY;

            // æ°´å¹³ç§»å‹•
            this.x += this.vx;

            // é‚Šç•Œåå½ˆ
            if (this.x <= 0) {
                this.x = 0;
                this.vx *= -1;
            } else if (this.x + this.width >= CANVAS_WIDTH) {
                this.x = CANVAS_WIDTH - this.width;
                this.vx *= -1;
            }

            // å¹³å°ç¢°æ’
            let onGround = false;
            for (let platform of platforms) {
                // å´é¢ç¢°æ’ (ç°¡å–®è™•ç†ï¼šåå½ˆ)
                if (this.y + this.height > platform.y + 5 && 
                    this.y < platform.y + platform.height && 
                    this.x + this.width > platform.x && 
                    this.x < platform.x + platform.width) {
                        this.vx *= -1;
                }

                // åœ°é¢ç¢°æ’
                if (this.vy >= 0 &&
                    this.x < platform.x + platform.width &&
                    this.x + this.width > platform.x &&
                    this.y + this.height > platform.y &&
                    this.y + this.height < platform.y + platform.height + 10) {
                    
                    this.y = platform.y - this.height;
                    this.vy = 0;
                    onGround = true;
                }
            }
            
            // éš¨æ©Ÿè·³èº
            if (onGround && Math.random() < 0.01) {
                this.vy = -8;
            }

            // æ‰å‡ºç•«é¢å›åˆ°é ‚éƒ¨
            if (this.y > CANVAS_HEIGHT) this.y = 0;

            // ç¢°åˆ°ç©å®¶
            if (this.collidesWith(player)) {
                player.hit();
            }

        } else if (this.state === 'trapped') {
            // è¢«æ³¡æ³¡å›°ä½çš„è¡Œç‚ºåœ¨ Bubble é¡åˆ¥ä¸­è™•ç†ï¼Œé€™è£¡åªéœ€è¦è™•ç†è¨ˆæ™‚
            // å¦‚æœå¯¦éš›ä¸Šä¸éœ€è¦é‚è¼¯ï¼Œå¯ç•™ç©º
        }
    }

    draw(ctx) {
        if (this.state === 'active') {
            // ç¹ªè£½æ•µäºº (ç™¼æ¢æ€ªç¸é¢¨æ ¼)
            ctx.save();
            ctx.translate(this.x + this.width/2, this.y + this.height/2);
            if (this.vx < 0) ctx.scale(-1, 1);
            
            // èº«é«”
            ctx.fillStyle = '#ff5252';
            ctx.fillRect(-15, -15, 30, 30);
            
            // çœ¼ç›
            ctx.fillStyle = 'white';
            ctx.fillRect(2, -10, 10, 10);
            ctx.fillStyle = 'black';
            ctx.fillRect(7, -8, 4, 4);

            // è…³
            if (Math.floor(Date.now() / 100) % 2 === 0) {
                ctx.fillStyle = '#d32f2f';
                ctx.fillRect(-10, 15, 8, 5);
                ctx.fillRect(5, 15, 8, 5);
            }

            ctx.restore();
        } 
        // Trapped ç‹€æ…‹ä¸ç¹ªè£½ï¼Œå› ç‚ºå®ƒæœƒåœ¨æ³¡æ³¡å…§éƒ¨
    }
}

/**
 * æ³¡æ³¡é¡åˆ¥
 */
class Bubble extends Entity {
    constructor(x, y, direction) {
        super(x, y, 32, 32, 'rgba(100, 200, 255, 0.5)');
        this.vx = direction * BUBBLE_SPEED;
        this.flyTime = 30; // æ°´å¹³é£›è¡Œæ™‚é–“
        this.lifeTime = BUBBLE_LIFETIME;
        this.trappedEnemy = null; // å­˜æ”¾è¢«å›°ä½çš„æ•µäºº
    }

    update() {
        this.lifeTime--;

        if (this.flyTime > 0) {
            // ç™¼å°„éšæ®µï¼šæ°´å¹³é£›è¡Œ
            this.flyTime--;
            this.x += this.vx;
            // é˜»åŠ›æ¸›é€Ÿ
            this.vx *= 0.95;
        } else {
            // æ¼‚æµ®éšæ®µï¼šæ…¢æ…¢å¾€ä¸Š
            this.vy = BUBBLE_FLOAT_SPEED;
            this.y += this.vy;
            
            // å·¦å³è¼•å¾®æ“ºå‹•
            this.x += Math.sin(this.lifeTime * 0.1) * 0.5;
        }

        // é‚Šç•Œæª¢æŸ¥
        if (this.x < 0) this.x = 0;
        if (this.x + this.width > CANVAS_WIDTH) this.x = CANVAS_WIDTH - this.width;
        if (this.y < -50) this.y = CANVAS_HEIGHT; // å¾ªç’°

        // æ³¡æ³¡ç ´è£‚
        if (this.lifeTime <= 0) {
            this.pop();
        }

        // é‚è¼¯åˆ†æ”¯ï¼šç©ºæ³¡æ³¡ vs åŒ…è£¹æ•µäººçš„æ³¡æ³¡
        if (!this.trappedEnemy) {
            // 1. æª¢æŸ¥æ˜¯å¦ç¢°åˆ°æ•µäºº (åŒ…è£¹æ•µäºº)
            for (let i = 0; i < enemies.length; i++) {
                let enemy = enemies[i];
                if (enemy.state === 'active' && this.collidesWith(enemy)) {
                    this.trapEnemy(enemy);
                    break;
                }
            }
        } else {
            // 2. å¦‚æœåŒ…è£¹äº†æ•µäººï¼Œç©å®¶ç¢°åˆ°æœƒæˆ³ç ´ä¸¦å¾—åˆ†
            if (this.collidesWith(player)) {
                // ç©å®¶æˆ³ç ´æ³¡æ³¡ -> æ®ºæ•µ -> è®Šæ°´æœ
                spawnFruit(this.x, this.y);
                createParticles(this.x + 16, this.y + 16, '#ff5252', 10);
                addScore(1000); // æ®ºæ•µåˆ†æ•¸
                this.pop();
            }
        }
        
        // ç©å®¶å¯ä»¥ç”¨é ­é ‚æ³¡æ³¡ (ç°¡å–®ç‰©ç†äº’å‹•ï¼šç¢°åˆ°æ³¡æ³¡åº•éƒ¨æœƒå½ˆä¸€ä¸‹)
        // é€™è£¡ç°¡åŒ–ç‚ºï¼šå¦‚æœç©å®¶åœ¨æ³¡æ³¡ä¸Šæ–¹è·³èºï¼Œæ³¡æ³¡ç ´è£‚ (å¦‚æœæ˜¯ç©ºæ³¡æ³¡)
        if (!this.trappedEnemy && this.collidesWith(player)) {
            // ç‚ºäº†ä¸è®“ç•«é¢å¤ªäº‚ï¼Œç©å®¶ç¢°åˆ°ç©ºæ³¡æ³¡ä¹Ÿæœƒç ´
            this.pop();
        }
    }

    trapEnemy(enemy) {
        this.trappedEnemy = enemy;
        enemy.state = 'trapped';
        enemy.x = -1000; // ç§»å‡ºç•«é¢
        this.lifeTime = 600; // å»¶é•·æ³¡æ³¡æ™‚é–“è®“ç©å®¶å»æˆ³
        this.color = 'rgba(255, 100, 100, 0.7)'; // è®Šç´…è‰²
    }

    pop() {
        this.markedForDeletion = true;
        // å¦‚æœæ•µäººè¢«å›°ä½ä½†æ³¡æ³¡è‡ªç„¶ç ´è£‚ï¼ˆè¶…æ™‚ï¼‰ï¼Œæ•µäººæœƒé€ƒè„«ä¸¦è®Šç”Ÿæ°£ï¼ˆé€™è£¡ç°¡åŒ–ç‚ºé‡‹æ”¾æ•µäººï¼‰
        if (this.trappedEnemy && !this.markedForDeletion) { // é€™è£¡é‚è¼¯æœ‰é»æ€ªï¼Œç°¡åŒ–ç‚ºï¼šç ´äº†å°±æ²’äº†ï¼Œå¦‚æœæ˜¯è¶…æ™‚ç ´è£‚ï¼Œæ•µäººæ‡‰è©²é‡ç”Ÿ
             // ç°¡å–®èµ·è¦‹ï¼Œè¶…æ™‚ç ´è£‚æ•µäººå°±é€ƒè·‘ï¼ˆè®Šå› activeï¼‰
             this.trappedEnemy.state = 'active';
             this.trappedEnemy.x = this.x;
             this.trappedEnemy.y = this.y;
             this.trappedEnemy.isAngry = true; // é ç•™å±¬æ€§
        }
        createParticles(this.x + 16, this.y + 16, '#aaddff', 5);
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x + 16, this.y + 16);
        
        // ç•«æ³¡æ³¡
        ctx.beginPath();
        ctx.arc(0, 0, 16, 0, Math.PI * 2);
        ctx.fillStyle = this.trappedEnemy ? 'rgba(255, 150, 150, 0.6)' : 'rgba(100, 220, 255, 0.4)';
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();

        // é«˜å…‰
        ctx.beginPath();
        ctx.arc(-5, -5, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.fill();

        // å¦‚æœæœ‰æ•µäººï¼Œç•«å€‹å°åœ–ç¤ºåœ¨è£¡é¢
        if (this.trappedEnemy) {
            ctx.fillStyle = '#a00000';
            ctx.font = '20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('x_x', 0, 2);
            // æ—‹è½‰å‹•ç•«
            ctx.rotate(Date.now() * 0.005);
        }

        ctx.restore();
    }
}

/**
 * æ°´æœ/åˆ†æ•¸é“å…·é¡åˆ¥
 */
class Fruit extends Entity {
    constructor(x, y) {
        super(x, y, 20, 20, 'orange');
        this.vy = -3; // å¾€ä¸Šè·³ä¸€ä¸‹
        this.vx = (Math.random() - 0.5) * 4;
        this.onGround = false;
    }
    
    update() {
        this.vy += GRAVITY;
        this.x += this.vx;
        this.y += this.vy;
        
        // ç¢°åˆ°åœ°æ¿åœä½
        for (let platform of platforms) {
             if (this.vy >= 0 &&
                this.x < platform.x + platform.width &&
                this.x + this.width > platform.x &&
                this.y + this.height > platform.y &&
                this.y + this.height < platform.y + platform.height + 10) {
                
                this.y = platform.y - this.height;
                this.vy = 0;
                this.vx = 0;
                this.onGround = true;
            }
        }

        if (this.collidesWith(player)) {
            addScore(500);
            this.markedForDeletion = true;
            createParticles(this.x + 10, this.y + 10, 'yellow', 10);
        }
    }

    draw(ctx) {
        ctx.font = '24px Arial';
        ctx.fillText('ğŸ', this.x, this.y + 20);
    }
}

/**
 * ç²’å­æ•ˆæœ
 */
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 6;
        this.vy = (Math.random() - 0.5) * 6;
        this.life = 1.0;
        this.color = color;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.05;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, 4, 4);
        ctx.globalAlpha = 1.0;
    }
}

/**
 * éŠæˆ²ä¸»é‚è¼¯
 */

function init() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');

    // ç›£è½éµç›¤
    window.addEventListener('keydown', e => {
        if (keys.hasOwnProperty(e.code)) keys[e.code] = true;
        if (e.code === 'Space' && gameOver) resetGame();
    });
    window.addEventListener('keyup', e => {
        if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
    });

    createLevel();
    player = new Player(50, CANVAS_HEIGHT - 100);
    
    // åˆå§‹æ•µäºº
    spawnEnemy();
    spawnEnemy();
    spawnEnemy();
}

function createLevel() {
    platforms = [];
    // åœ°æ¿
    platforms.push({x: 0, y: CANVAS_HEIGHT - 20, width: CANVAS_WIDTH, height: 20});
    // ç‰†å£
    platforms.push({x: -20, y: 0, width: 20, height: CANVAS_HEIGHT});
    platforms.push({x: CANVAS_WIDTH, y: 0, width: 20, height: CANVAS_HEIGHT});
    // å±‹é ‚
    platforms.push({x: 0, y: -20, width: CANVAS_WIDTH, height: 20});

    // å¹³å°ä½ˆå±€ (Lå‹çµæ§‹èˆ‡ä¸­é–“å¹³å°)
    platforms.push({x: 200, y: 450, width: 400, height: 20});
    
    platforms.push({x: 100, y: 300, width: 200, height: 20});
    platforms.push({x: 500, y: 300, width: 200, height: 20});

    platforms.push({x: 300, y: 150, width: 200, height: 20});
}

function spawnEnemy() {
    let x = Math.random() * (CANVAS_WIDTH - 60) + 30;
    let y = Math.random() * (CANVAS_HEIGHT - 200);
    enemies.push(new Enemy(x, y));
}

function shootBubble(player) {
    let direction = player.facingRight ? 1 : -1;
    let bx = player.x + (player.facingRight ? player.width : -32);
    let by = player.y;
    bubbles.push(new Bubble(bx, by, direction));
}

function spawnFruit(x, y) {
    fruits.push(new Fruit(x, y));
}

function createParticles(x, y, color, count) {
    for(let i=0; i<count; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function addScore(points) {
    score += points;
    document.getElementById('score').textContent = score;
    
    // æ¯ 5000 åˆ†åŠ ä¸€éš»æ•µäºº (å¢åŠ é›£åº¦)
    if (score % 2000 === 0) {
        spawnEnemy();
    }
}

function gameLoop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    if (!gameOver) {
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // ç¹ªè£½èƒŒæ™¯ç¶²æ ¼
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i < CANVAS_WIDTH; i+=50) { ctx.moveTo(i, 0); ctx.lineTo(i, CANVAS_HEIGHT); }
        for (let i = 0; i < CANVAS_HEIGHT; i+=50) { ctx.moveTo(0, i); ctx.lineTo(CANVAS_WIDTH, i); }
        ctx.stroke();

        // ç¹ªè£½å¹³å°
        ctx.fillStyle = '#795548';
        for (let p of platforms) {
            ctx.fillRect(p.x, p.y, p.width, p.height);
            // å¹³å°é ‚éƒ¨äº®æ¢
            ctx.fillStyle = '#a1887f';
            ctx.fillRect(p.x, p.y, p.width, 4);
            ctx.fillStyle = '#795548';
        }

        // æ›´æ–°èˆ‡ç¹ªè£½ç©å®¶
        player.update();
        player.draw(ctx);

        // æ›´æ–°èˆ‡ç¹ªè£½æ•µäºº
        enemies.forEach(e => {
            e.update();
            e.draw(ctx);
        });

        // æ›´æ–°èˆ‡ç¹ªè£½æ³¡æ³¡
        bubbles = bubbles.filter(b => !b.markedForDeletion);
        bubbles.forEach(b => {
            b.update();
            b.draw(ctx);
        });

        // æ›´æ–°èˆ‡ç¹ªè£½æ°´æœ
        fruits = fruits.filter(f => !f.markedForDeletion);
        fruits.forEach(f => {
            f.update();
            f.draw(ctx);
        });

        // æ›´æ–°èˆ‡ç¹ªè£½ç²’å­
        particles = particles.filter(p => p.life > 0);
        particles.forEach(p => {
            p.update();
            p.draw(ctx);
        });

        // ç°¡å–®çš„æ•µäººé‡ç”Ÿæ©Ÿåˆ¶ï¼šå¦‚æœæ•µäººå¤ªå°‘ï¼Œæ…¢æ…¢è£œ
        if (enemies.filter(e => e.state === 'active').length === 0 && frameCount % 300 === 0) {
            spawnEnemy();
            spawnEnemy(); // ä¸‹ä¸€æ³¢
        }
        
        frameCount++;
    }

    animationId = requestAnimationFrame(gameLoop);
}

function startGame() {
    document.getElementById('start-screen').classList.add('hidden');
    init();
    gameLoop(0);
}

function resetGame() {
    document.getElementById('game-over-screen').classList.add('hidden');
    score = 0;
    lives = 3;
    gameOver = false;
    document.getElementById('score').textContent = score;
    document.getElementById('lives').textContent = lives;
    
    // æ¸…ç©ºå¯¦é«”
    bubbles = [];
    enemies = [];
    fruits = [];
    particles = [];
    
    init();
}

// åˆå§‹è¼‰å…¥æ™‚ä¸è‡ªå‹•é–‹å§‹ï¼Œç­‰å¾…ç”¨æˆ¶é»æ“Š
ctx = document.getElementById('gameCanvas').getContext('2d');
ctx.fillStyle = '#111';
ctx.fillRect(0,0,800,600);

</script>
</body>
</html>